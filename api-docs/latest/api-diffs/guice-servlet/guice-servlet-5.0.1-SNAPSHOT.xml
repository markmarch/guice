<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Wed Jan 27 02:03:51 UTC 2021 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="guice-servlet-5.0.1-SNAPSHOT"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -apiname guice-servlet-5.0.1-SNAPSHOT -apidir /home/runner/work/guice/guice/extensions/servlet/target/site/api-diffs/guice-servlet -classpath /home/runner/work/guice/guice/extensions/servlet/target/guice-servlet-5.0.1-SNAPSHOT.jar:/home/runner/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/home/runner/.m2/repository/com/google/code/findbugs/jsr305/3.0.1/jsr305-3.0.1.jar:/home/runner/.m2/repository/com/google/inject/guice/5.0.1-SNAPSHOT/guice-5.0.1-SNAPSHOT.jar:/home/runner/.m2/repository/org/checkerframework/checker-qual/2.5.2/checker-qual-2.5.2.jar:/home/runner/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/home/runner/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/home/runner/.m2/repository/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar:/home/runner/.m2/repository/com/google/errorprone/error_prone_annotations/2.2.0/error_prone_annotations-2.2.0.jar:/home/runner/.m2/repository/com/google/guava/guava/27.1-jre/guava-27.1-jre.jar:/home/runner/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.17/animal-sniffer-annotations-1.17.jar:/home/runner/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar -sourcepath /tmp/jdiff11347210426287270433/guice-servlet/5.0.1-SNAPSHOT/sources -->
<package name="com.google.inject.servlet">
  <!-- start class com.google.inject.servlet.GuiceFilter -->
  <class name="GuiceFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GuiceFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletRequest" type="ServletRequest"/>
      <param name="servletResponse" type="ServletResponse"/>
      <param name="filterChain" type="FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterConfig" type="FilterConfig"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Apply this filter in web.xml above all other filters (typically), to all requests where you plan
 to use servlet scopes. This is also needed in order to dispatch requests to injectable filters
 and servlets:

 <pre>
  &lt;filter&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;<b>com.google.inject.servlet.GuiceFilter</b>&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  </pre>

 This filter must appear before every filter that makes use of Guice injection or servlet scopes
 functionality. Typically, you will only register this filter in web.xml and register any other
 filters (and servlets) using a {@link ServletModule}.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.GuiceFilter -->
  <!-- start class com.google.inject.servlet.GuiceServletContextListener -->
  <class name="GuiceServletContextListener" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GuiceServletContextListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="contextInitialized"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="ServletContextEvent"/>
    </method>
    <method name="contextDestroyed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="ServletContextEvent"/>
    </method>
    <method name="getInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override this method to create (or otherwise obtain a reference to) your injector.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[As of Guice 2.0 you can still use (your subclasses of) {@code GuiceServletContextListener} class
 as a logical place to create and configure your injector. This will ensure the injector is
 created when the web application is deployed.

 @author Kevin Bourrillion (kevinb@google.com)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.GuiceServletContextListener -->
  <!-- start interface com.google.inject.servlet.InstanceFilterBinding -->
  <interface name="InstanceFilterBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getFilterInstance" return="Filter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the filter instance that will be used.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance of a filter.

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.InstanceFilterBinding -->
  <!-- start interface com.google.inject.servlet.InstanceServletBinding -->
  <interface name="InstanceServletBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getServletInstance" return="HttpServlet"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the servlet instance that will be used.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance of a servlet.

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.InstanceServletBinding -->
  <!-- start interface com.google.inject.servlet.LinkedFilterBinding -->
  <interface name="LinkedFilterBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getLinkedKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to lookup the filter instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A linked binding to a filter.

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.LinkedFilterBinding -->
  <!-- start interface com.google.inject.servlet.LinkedServletBinding -->
  <interface name="LinkedServletBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getLinkedKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to lookup the servlet instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A linked binding to a servlet.

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.LinkedServletBinding -->
  <!-- start interface com.google.inject.servlet.RequestParameters -->
  <interface name="RequestParameters"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to field or parameters of type {@code Map<String, String[]>} when you want the HTTP
 request parameter map to be injected.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.RequestParameters -->
  <!-- start interface com.google.inject.servlet.RequestScoped -->
  <interface name="RequestScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per request.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.RequestScoped -->
  <!-- start interface com.google.inject.servlet.RequestScoper -->
  <interface name="RequestScoper"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="open" return="com.google.inject.servlet.RequestScoper.CloseableScope"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Opens up the request scope until the returned object is closed. Implementations should ensure
 (e.g. by blocking) that multiple threads cannot open the same request scope concurrently. It is
 allowable to open the same request scope on the same thread, as long as open/close calls are
 correctly nested.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Object that can be used to apply a request scope to a block of code.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.RequestScoper -->
  <!-- start interface com.google.inject.servlet.RequestScoper.CloseableScope -->
  <interface name="RequestScoper.CloseableScope"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Closeable subclass that does not throw any exceptions from close.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.RequestScoper.CloseableScope -->
  <!-- start class com.google.inject.servlet.ScopingException -->
  <class name="ScopingException" extends="java.lang.IllegalStateException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ScopingException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown when there was a failure entering request scope.

 @author Chris Nokleberg
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ScopingException -->
  <!-- start interface com.google.inject.servlet.ScopingOnly -->
  <interface name="ScopingOnly"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates a {@link GuiceFilter} that provides scope functionality, but doesn't dispatch to {@link
 ServletModule} bound servlets or filters.

 @author iqshum@google.com (Isaac Shum)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ScopingOnly -->
  <!-- start class com.google.inject.servlet.ServletModule -->
  <class name="ServletModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServletModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="configureServlets"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<h3>Servlet Mapping EDSL</h3>

 <p>Part of the EDSL builder language for configuring servlets and filters with guice-servlet.
 Think of this as an in-code replacement for web.xml. Filters and servlets are configured here
 using simple java method calls. Here is a typical example of registering a filter when creating
 your Guice injector:

 <pre>
   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       <b>serve("*.html").with(MyServlet.class)</b>
     }
   }
 </pre>

 This registers a servlet (subclass of {@code HttpServlet}) called {@code MyServlet} to service
 any web pages ending in {@code .html}. You can also use a path-style syntax to register
 servlets:

 <pre>
       <b>serve("/my/*").with(MyServlet.class)</b>
 </pre>

 Every servlet (or filter) is required to be a singleton. If you cannot annotate the class
 directly, you should add a separate {@code bind(..).in(Singleton.class)} rule elsewhere in your
 module. Mapping a servlet that is bound under any other scope is an error.

 <p>

 <h4>Dispatch Order</h4>

 You are free to register as many servlets and filters as you like this way. They will be
 compared and dispatched in the order in which the filter methods are called:

 <pre>

   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       filter("/*").through(MyFilter.class);
       filter("*.css").through(MyCssFilter.class);
       filter("*.jpg").through(new MyJpgFilter());
       // etc..

       serve("*.html").with(MyServlet.class);
       serve("/my/*").with(MyServlet.class);
       serve("*.jpg").with(new MyServlet());
       // etc..
      }
    }
 </pre>

 This will traverse down the list of rules in lexical order. For example, a url "{@code
 /my/file.js}" (after it runs through the matching filters) will first be compared against the
 servlet mapping:

 <pre>
       serve("*.html").with(MyServlet.class);
 </pre>

 And failing that, it will descend to the next servlet mapping:

 <pre>
       serve("/my/*").with(MyServlet.class);
 </pre>

 Since this rule matches, Guice Servlet will dispatch to {@code MyServlet}. These two mapping
 rules can also be written in more compact form using varargs syntax:

 <pre>
       serve(<b>"*.html", "/my/*"</b>).with(MyServlet.class);
 </pre>

 This way you can map several URI patterns to the same servlet. A similar syntax is also
 available for filter mappings.

 <p>

 <h4>Regular Expressions</h4>

 You can also map servlets (or filters) to URIs using regular expressions:

 <pre>
    <b>serveRegex("(.)*ajax(.)*").with(MyAjaxServlet.class)</b>
 </pre>

 This will map any URI containing the text "ajax" in it to {@code MyAjaxServlet}. Such as:

 <ul>
 <li>http://www.google.com/ajax.html
 <li>http://www.google.com/content/ajax/index
 <li>http://www.google.com/it/is_totally_ajaxian
 </ul>

 <h3>Initialization Parameters</h3>

 Servlets (and filters) allow you to pass in init params using the {@code <init-param>} tag in
 web.xml. You can similarly pass in parameters to Servlets and filters registered in
 Guice-servlet using a {@link java.util.Map} of parameter name/value pairs. For example, to
 initialize {@code MyServlet} with two parameters ({@code name="Dhanji", site="google.com"}) you
 could write:

 <pre>
  Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
  params.put("name", "Dhanji");
  params.put("site", "google.com");

  ...
      serve("/*").with(MyServlet.class, <b>params</b>)
 </pre>

 <p>

 <h3>Binding Keys</h3>

 You can also bind keys rather than classes. This lets you hide implementations with
 package-local visbility and expose them using only a Guice module and an annotation:

 <pre>
  ...
      filter("/*").through(<b>Key.get(Filter.class, Fave.class)</b>);
 </pre>

 Where {@code Filter.class} refers to the Servlet API interface and {@code Fave.class} is a
 custom binding annotation. Elsewhere (in one of your own modules) you can bind this filter's
 implementation:

 <pre>
   bind(Filter.class)<b>.annotatedWith(Fave.class)</b>.to(MyFilterImpl.class);
 </pre>

 See {@link com.google.inject.Binder} for more information on binding syntax.

 <p>

 <h3>Multiple Modules</h3>

 It is sometimes useful to capture servlet and filter mappings from multiple different modules.
 This is essential if you want to package and offer drop-in Guice plugins that provide servlet
 functionality.

 <p>Guice Servlet allows you to register several instances of {@code ServletModule} to your
 injector. The order in which these modules are installed determines the dispatch order of
 filters and the precedence order of servlets. For example, if you had two servlet modules,
 {@code RpcModule} and {@code WebServiceModule} and they each contained a filter that mapped to
 the same URI pattern, {@code "/*"}:

 <p>In {@code RpcModule}:

 <pre>
     filter("/*").through(RpcFilter.class);
 </pre>

 In {@code WebServiceModule}:

 <pre>
     filter("/*").through(WebServiceFilter.class);
 </pre>

 Then the order in which these filters are dispatched is determined by the order in which the
 modules are installed:

 <pre>
   <b>install(new WebServiceModule());</b>
   install(new RpcModule());
 </pre>

 In the case shown above {@code WebServiceFilter} will run first.

 @since 2.0]]>
      </doc>
    </method>
    <method name="filter" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPattern" type="java.lang.String"/>
      <param name="morePatterns" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 @since 2.0]]>
      </doc>
    </method>
    <method name="filter" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPatterns" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[@param urlPatterns Any Servlet-style patterns. examples: /*, /html/*, *.html, etc.
 @since 4.1]]>
      </doc>
    </method>
    <method name="filterRegex" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <param name="regexes" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param regex Any Java-style regular expression.
 @since 2.0]]>
      </doc>
    </method>
    <method name="filterRegex" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regexes" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[@param regexes Any Java-style regular expressions.
 @since 4.1]]>
      </doc>
    </method>
    <method name="serve" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPattern" type="java.lang.String"/>
      <param name="morePatterns" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 @since 2.0]]>
      </doc>
    </method>
    <method name="serve" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPatterns" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[@param urlPatterns Any Servlet-style patterns. examples: /*, /html/*, *.html, etc.
 @since 4.1]]>
      </doc>
    </method>
    <method name="serveRegex" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <param name="regexes" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param regex Any Java-style regular expression.
 @since 2.0]]>
      </doc>
    </method>
    <method name="serveRegex" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regexes" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[@param regexes Any Java-style regular expressions.
 @since 4.1]]>
      </doc>
    </method>
    <method name="getServletContext" return="ServletContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method only works if you are using the {@linkplain GuiceServletContextListener} to create
 your injector. Otherwise, it returns null.

 @return The current servlet context.
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Configures the servlet scopes and creates bindings for the servlet API objects so you can inject
 the request, response, session, etc.

 <p>You should subclass this module to register servlets and filters in the {@link
 #configureServlets()} method.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletModule -->
  <!-- start interface com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder -->
  <interface name="ServletModule.FilterKeyBindingBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="java.lang.Class"/>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="com.google.inject.Key"/>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="Filter"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="java.lang.Class"/>
      <param name="initParams" type="java.util.Map"/>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="com.google.inject.Key"/>
      <param name="initParams" type="java.util.Map"/>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="Filter"/>
      <param name="initParams" type="java.util.Map"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link ServletModule#configureServlets()}

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder -->
  <!-- start interface com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder -->
  <interface name="ServletModule.ServletKeyBindingBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="java.lang.Class"/>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="com.google.inject.Key"/>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servlet" type="HttpServlet"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="java.lang.Class"/>
      <param name="initParams" type="java.util.Map"/>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="com.google.inject.Key"/>
      <param name="initParams" type="java.util.Map"/>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servlet" type="HttpServlet"/>
      <param name="initParams" type="java.util.Map"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link ServletModule#configureServlets()}

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder -->
  <!-- start interface com.google.inject.servlet.ServletModuleBinding -->
  <interface name="ServletModuleBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUriPatternType" return="com.google.inject.servlet.UriPatternType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the pattern type that this binding was created with.]]>
      </doc>
    </method>
    <method name="getPattern" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the pattern used to match against the binding.]]>
      </doc>
    </method>
    <method name="getInitParams" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns any context params supplied when creating the binding.]]>
      </doc>
    </method>
    <method name="matchesUri" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if the given URI will match this binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding created by {@link ServletModule}.

 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModuleBinding -->
  <!-- start interface com.google.inject.servlet.ServletModuleTargetVisitor -->
  <interface name="ServletModuleTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor"/>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.LinkedFilterBinding"/>
      <doc>
      <![CDATA[Visits a filter binding created by {@link ServletModule#filter}, where {@link
 FilterKeyBindingBuilder#through} is called with a Class or Key.

 <p>If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.InstanceFilterBinding"/>
      <doc>
      <![CDATA[Visits a filter binding created by {@link ServletModule#filter} where {@link
 FilterKeyBindingBuilder#through} is called with a {@link Filter}.

 <p>If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.LinkedServletBinding"/>
      <doc>
      <![CDATA[Visits a servlet binding created by {@link ServletModule#serve} where {@link
 ServletKeyBindingBuilder#with}, is called with a Class or Key.

 <p>If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.InstanceServletBinding"/>
      <doc>
      <![CDATA[Visits a servlet binding created by {@link ServletModule#serve} where {@link
 ServletKeyBindingBuilder#with}, is called with an {@link HttpServlet}.

 <p>If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the servlet extension.

 <p>If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@link ServletModule} will be visited through this interface.

 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModuleTargetVisitor -->
  <!-- start class com.google.inject.servlet.ServletScopes -->
  <class name="ServletScopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="continueRequest" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="You probably want to use {@code transferRequest} instead">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="seedMap" type="java.util.Map"/>
      <doc>
      <![CDATA[Wraps the given callable in a contextual callable that "continues" the HTTP request in another
 thread. This acts as a way of transporting request context data from the request processing
 thread to to worker threads.

 <p>There are some limitations:

 <ul>
 <li>Derived objects (i.e. anything marked @RequestScoped will not be transported.
 <li>State changes to the HttpServletRequest after this method is called will not be seen in the
     continued thread.
 <li>Only the HttpServletRequest, ServletContext and request parameter map are available in the
     continued thread. The response and session are not available.
 </ul>

 <p>The returned callable will throw a {@link ScopingException} when called if the HTTP request
 scope is still active on the current thread.

 @param callable code to be executed in another thread, which depends on the request scope.
 @param seedMap the initial set of scoped instances for Guice to seed the request scope with. To
     seed a key with null, use {@code null} as the value.
 @return a callable that will invoke the given callable, making the request context available to
     it.
 @throws OutOfScopeException if this method is called from a non-request thread, or if the
     request has completed.
 @since 3.0
 @deprecated You probably want to use {@code transferRequest} instead]]>
      </doc>
    </method>
    <method name="transferRequest" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <doc>
      <![CDATA[Wraps the given callable in a contextual callable that "transfers" the request to another
 thread. This acts as a way of transporting request context data from the current thread to a
 future thread.

 <p>As opposed to {@link #continueRequest}, this method propagates all existing scoped objects.
 The primary use case is in server implementations where you can detach the request processing
 thread while waiting for data, and reattach to a different thread to finish processing at a
 later time.

 <p>Because request-scoped objects are not typically thread-safe, the callable returned by this
 method must not be run on a different thread until the current request scope has terminated.
 The returned callable will block until the current thread has released the request scope.

 @param callable code to be executed in another thread, which depends on the request scope.
 @return a callable that will invoke the given callable, making the request context available to
     it.
 @throws OutOfScopeException if this method is called from a non-request thread, or if the
     request has completed.
 @since 4.0]]>
      </doc>
    </method>
    <method name="transferRequest" return="com.google.inject.servlet.RequestScoper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an object that "transfers" the request to another thread. This acts as a way of
 transporting request context data from the current thread to a future thread. The transferred
 scope is the one active for the thread that calls this method. A later call to {@code open()}
 activates the transferred the scope, including propagating any objects scoped at that time.

 <p>As opposed to {@link #continueRequest}, this method propagates all existing scoped objects.
 The primary use case is in server implementations where you can detach the request processing
 thread while waiting for data, and reattach to a different thread to finish processing at a
 later time.

 <p>Because request-scoped objects are not typically thread-safe, it is important to avoid
 applying the same request scope concurrently. The returned Scoper will block on open until the
 current thread has released the request scope.

 @return an object that when opened will initiate the request scope
 @throws OutOfScopeException if this method is called from a non-request thread, or if the
     request has completed.
 @since 4.1]]>
      </doc>
    </method>
    <method name="isRequestScoped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding"/>
      <doc>
      <![CDATA[Returns true if {@code binding} is request-scoped. If the binding is a {@link
 com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (i. e. it
 was retrieved via {@link Injector#getBinding Injector.getBinding()}), then this method will
 also return true if the target binding is request-scoped.

 @since 4.0]]>
      </doc>
    </method>
    <method name="scopeRequest" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="seedMap" type="java.util.Map"/>
      <doc>
      <![CDATA[Scopes the given callable inside a request scope. This is not the same as the HTTP request
 scope, but is used if no HTTP request scope is in progress. In this way, keys can be scoped
 as @RequestScoped and exist in non-HTTP requests (for example: RPC requests) as well as in HTTP
 request threads.

 <p>The returned callable will throw a {@link ScopingException} when called if there is a
 request scope already active on the current thread.

 @param callable code to be executed which depends on the request scope. Typically in another
     thread, but not necessarily so.
 @param seedMap the initial set of scoped instances for Guice to seed the request scope with. To
     seed a key with null, use {@code null} as the value.
 @return a callable that when called will run inside the a request scope that exposes the
     instances in the {@code seedMap} as scoped keys.
 @since 3.0]]>
      </doc>
    </method>
    <method name="scopeRequest" return="com.google.inject.servlet.RequestScoper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seedMap" type="java.util.Map"/>
      <doc>
      <![CDATA[Returns an object that will apply request scope to a block of code. This is not the same as the
 HTTP request scope, but is used if no HTTP request scope is in progress. In this way, keys can
 be scoped as @RequestScoped and exist in non-HTTP requests (for example: RPC requests) as well
 as in HTTP request threads.

 <p>The returned object will throw a {@link ScopingException} when opened if there is a request
 scope already active on the current thread.

 @param seedMap the initial set of scoped instances for Guice to seed the request scope with. To
     seed a key with null, use {@code null} as the value.
 @return an object that when opened will initiate the request scope
 @since 4.1]]>
      </doc>
    </method>
    <field name="REQUEST" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP servlet request scope.]]>
      </doc>
    </field>
    <field name="SESSION" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP session scope.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Servlet scopes.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletScopes -->
  <!-- start interface com.google.inject.servlet.SessionScoped -->
  <interface name="SessionScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per session.

 @see com.google.inject.Scopes#SINGLETON
 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.SessionScoped -->
  <!-- start class com.google.inject.servlet.UriPatternType -->
  <class name="UriPatternType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.servlet.UriPatternType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.servlet.UriPatternType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="SERVLET" type="com.google.inject.servlet.UriPatternType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="REGEX" type="com.google.inject.servlet.UriPatternType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An enumeration of the available URI-pattern matching styles

 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.UriPatternType -->
</package>

</api>
