<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Wed Jan 27 00:20:13 UTC 2021 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="guice-testlib-5.0.1-SNAPSHOT"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -apiname guice-testlib-5.0.1-SNAPSHOT -apidir /home/runner/work/guice/guice/extensions/testlib/target/site/api-diffs/guice-testlib -classpath /home/runner/.m2/repository/com/google/code/findbugs/jsr305/3.0.1/jsr305-3.0.1.jar:/home/runner/work/guice/guice/extensions/testlib/target/guice-testlib-5.0.1-SNAPSHOT.jar:/home/runner/.m2/repository/com/google/inject/extensions/guice-throwingproviders/5.0.1-SNAPSHOT/guice-throwingproviders-5.0.1-SNAPSHOT.jar:/home/runner/.m2/repository/org/checkerframework/checker-qual/2.5.2/checker-qual-2.5.2.jar:/home/runner/.m2/repository/com/google/auto/value/auto-value-annotations/1.6.3/auto-value-annotations-1.6.3.jar:/home/runner/.m2/repository/com/google/inject/guice/5.0.1-SNAPSHOT/guice-5.0.1-SNAPSHOT.jar:/home/runner/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/home/runner/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.1/error_prone_annotations-2.3.1.jar:/home/runner/.m2/repository/com/google/truth/truth/0.45/truth-0.45.jar:/home/runner/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/home/runner/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/home/runner/.m2/repository/org/checkerframework/checker-compat-qual/2.5.5/checker-compat-qual-2.5.5.jar:/home/runner/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/home/runner/.m2/repository/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar:/home/runner/.m2/repository/com/googlecode/java-diff-utils/diffutils/1.3.0/diffutils-1.3.0.jar:/home/runner/.m2/repository/com/google/guava/guava/27.1-jre/guava-27.1-jre.jar:/home/runner/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.17/animal-sniffer-annotations-1.17.jar -sourcepath /tmp/jdiff4187322276753121281/guice-testlib/5.0.1-SNAPSHOT/sources -->
<package name="com.google.inject.testing.throwingproviders">
  <!-- start class com.google.inject.testing.throwingproviders.CheckedProviderSubject -->
  <class name="CheckedProviderSubject" extends="com.google.common.truth.Subject"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkedProviders" return="com.google.common.truth.Subject.Factory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="assertThat" return="com.google.inject.testing.throwingproviders.CheckedProviderSubject"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="com.google.inject.throwingproviders.CheckedProvider"/>
    </method>
    <method name="providedValue" return="com.google.common.truth.Subject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows for assertions on the value provided by this provider.

 <p>The value provided by a checked provider is the object returned by a call to {@link
 CheckedProvider#get}

 @return a {@link Subject} for asserting against the return value of {@link CheckedProvider#get}]]>
      </doc>
    </method>
    <method name="thrownException" return="com.google.common.truth.ThrowableSubject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows for assertions on the exception thrown by this provider.

 <p>The exception thrown by a checked provider is the {@link Throwable} thrown by a call to
 {@link CheckedProvider#get}

 @return a {@link ThrowableSubject} for asserting against the {@link Throwable} thrown by {@link
     CheckedProvider#get}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Truth {@link Subject} for use with {@link CheckedProvider} classes.

 @author eatnumber1@google.com (Russ Harmon)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.testing.throwingproviders.CheckedProviderSubject -->
</package>
<package name="com.google.inject.testing.fieldbinder">
  <!-- start interface com.google.inject.testing.fieldbinder.Bind -->
  <interface name="Bind"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="to" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If specified, {@link BoundFieldModule} will bind the annotated field's value to this type,
 rather than to the field's actual type.]]>
      </doc>
    </method>
    <method name="lazy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If true, {@link BoundFieldModule} will delay reading the field until injection time rather than
 eagerly reading it at configure time.

 <p>When used with Provider valued fields, the provider will be read from the field and {@code
 .get()} will be called for each provision. This may be useful for testing provision failures.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Annotation used by {@link BoundFieldModule} to indicate that a field should be bound to its value
 using Guice.

 <p>{@Bind} supports binding annotations. For example, to bind a {@code @Fast Car}, use
 {@code @Bind @Fast Car}.

 <p>Binding to {@code null} is only allowed for fields that are annotated {@code @Nullable}. See
 <a
 href="https://github.com/google/guice/wiki/UseNullable">https://github.com/google/guice/wiki/UseNullable</a>

 @see BoundFieldModule
 @author eatnumber1@google.com (Russ Harmon)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.testing.fieldbinder.Bind -->
  <!-- start class com.google.inject.testing.fieldbinder.BoundFieldModule -->
  <class name="BoundFieldModule" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <method name="of" return="com.google.inject.testing.fieldbinder.BoundFieldModule"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Create a BoundFieldModule which binds the {@link Bind} annotated fields of {@code instance}.

 @param instance the instance whose fields will be bound.
 @return a module which will bind the {@link Bind} annotated fields of {@code instance}.]]>
      </doc>
    </method>
    <method name="getInstance" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the the object originally passed to {@link BoundFieldModule#of}).]]>
      </doc>
    </method>
    <method name="getBoundFields" return="com.google.common.collect.ImmutableSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns information about the fields bound by this module.

 <p>Note this is available immediately after construction, fields with errors won't be included
 but their error messages will be deferred to configuration time.

 <p>Fields with invalid null values <em>are</em> included but still cause errors at
 configuration time.]]>
      </doc>
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[A Guice module that automatically adds Guice bindings into the injector for all {@link Bind}
 annotated fields of a specified object.

 <p>This module is intended for use in tests to reduce the amount of boilerplate code needed to
 bind local fields (usually mocks) for injection.

 <p>The following rules are followed in determining how fields are bound using this module:

 <ul>
   <li>For each {@link Bind} annotated field of an object and its superclasses, this module will
       bind that field's type to that field's value at injector creation time. This includes both
       instance and static fields.
   <li>If {@link Bind#to} is specified, the field's value will be bound to the class specified by
       {@link Bind#to} instead of the field's actual type.
   <li>If {@link Bind#lazy} is true, this module will delay reading the value from the field until
       injection time, allowing the field's value to be reassigned during the course of a test's
       execution.
   <li>If a {@link BindingAnnotation} or {@link javax.inject.Qualifier} is present on the field,
       that field will be bound using that annotation via {@link
       AnnotatedBindingBuilder#annotatedWith}. For example, {@code
       bind(Foo.class).annotatedWith(BarAnnotation.class).toInstance(theValue)}. It is an error to
       supply more than one {@link BindingAnnotation} or {@link javax.inject.Qualifier}.
   <li>If the field is of type {@link Provider}, the field's value will be bound as a {@link
       Provider} using {@link LinkedBindingBuilder#toProvider} to the provider's parameterized
       type. For example, {@code Provider<Integer>} binds to {@link Integer}. Attempting to bind a
       non-parameterized {@link Provider} without a {@link Bind#to} clause is an error.
 </ul>

 <p>Example use:

 <pre><code>
 public class TestFoo {
   // bind(new TypeLiteral{@code <List<Object>>}() {}).toInstance(listOfObjects);
   {@literal @}Bind private List{@code <Object>} listOfObjects = Lists.of();

   // private String userName = "string_that_changes_over_time";
   // bind(String.class).toProvider(new Provider() { public String get() { return userName; }});
   {@literal @}Bind(lazy = true) private String userName;

   // bind(SuperClass.class).toInstance(aSubClass);
   {@literal @}Bind(to = SuperClass.class) private SubClass aSubClass = new SubClass();

   // bind(String.class).annotatedWith(MyBindingAnnotation.class).toInstance(myString);
   {@literal @}Bind
   {@literal @}MyBindingAnnotation
   private String myString = "hello";

   // bind(Object.class).toProvider(myProvider);
   {@literal @}Bind private Provider{@code <Object>} myProvider = getProvider();

   {@literal @}Before public void setUp() {
     Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
   }
 }
 </code></pre>

 @see Bind
 @author eatnumber1@google.com (Russ Harmon)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.testing.fieldbinder.BoundFieldModule -->
  <!-- start class com.google.inject.testing.fieldbinder.BoundFieldModule.BoundFieldInfo -->
  <class name="BoundFieldModule.BoundFieldInfo" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getField" return="java.lang.reflect.Field"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The field itself.]]>
      </doc>
    </method>
    <method name="getFieldType" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The actual type of the field.

 <p>For example, {@code @Bind(to = Object.class) Number one = new Integer(1);} will be {@code
 Number}. {@code @Bind Provider<Number>} will be {@code Provider<Number>}.]]>
      </doc>
    </method>
    <method name="getBindAnnotation" return="com.google.inject.testing.fieldbinder.Bind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The {@literal @}{@link Bind} annotation which is present on the field.

 <p>Note this is not the same as the binding annotation (or qualifier) for {@link
 #getBoundKey()}]]>
      </doc>
    </method>
    <method name="getBoundKey" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The key this field will bind to.

 <ul>
   <li>{@code @Bind(to = Object.class) @MyQualifier Number one = new Integer(1);} will be
       {@code @MyQualifier Object}.
   <li>{@code @Bind @MyQualifier(2) Number one = new Integer(1);} will be
       {@code @MyQualifier(2) Number}.
   <li>{@code @Bind @MyQualifier Provider<String> three = "default"} will be
       {@code @MyQualfier String}
 </ul>]]>
      </doc>
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current value of this field.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Information about a field bound by {@link BoundFieldModule}.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.testing.fieldbinder.BoundFieldModule.BoundFieldInfo -->
  <!-- start class com.google.inject.testing.fieldbinder.BoundFieldModule.WithPermits -->
  <class name="BoundFieldModule.WithPermits" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WithPermits" type="java.lang.Object"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Wrapper of BoundFieldModule which enables attaching {@link @RestrictedBindingSource} permits to
 instances of it.

 <p>To create an instance of BoundFieldModule with permits (to enable it to bind restricted
 bindings), create an instance of an anonymous class extending this one and annotate it with
 those permits. For example: {@code new @Permit1 @Permit2 BoundFieldModule.WithPermits(instance)
 {}}.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.testing.fieldbinder.BoundFieldModule.WithPermits -->
</package>

</api>
