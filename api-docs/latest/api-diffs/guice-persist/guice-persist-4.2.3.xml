<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Wed Jan 27 02:03:25 UTC 2021 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="guice-persist-4.2.3"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -apiname guice-persist-4.2.3 -apidir /home/runner/work/guice/guice/extensions/persist/target/site/api-diffs/guice-persist -classpath /home/runner/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/home/runner/.m2/repository/com/google/code/findbugs/jsr305/3.0.1/jsr305-3.0.1.jar:/home/runner/.m2/repository/com/google/inject/guice/4.2.3/guice-4.2.3.jar:/home/runner/.m2/repository/org/checkerframework/checker-qual/2.5.2/checker-qual-2.5.2.jar:/home/runner/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/home/runner/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/home/runner/.m2/repository/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar:/home/runner/.m2/repository/com/google/errorprone/error_prone_annotations/2.2.0/error_prone_annotations-2.2.0.jar:/home/runner/.m2/repository/com/google/inject/extensions/guice-persist/4.2.3/guice-persist-4.2.3.jar:/home/runner/.m2/repository/com/google/guava/guava/27.1-jre/guava-27.1-jre.jar:/home/runner/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.17/animal-sniffer-annotations-1.17.jar:/home/runner/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar -sourcepath /tmp/jdiff5062350981469470248/guice-persist/4.2.3/sources -->
<package name="com.google.inject.persist.finder">
  <!-- start class com.google.inject.persist.finder.DynamicFinder -->
  <class name="DynamicFinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DynamicFinder" type="java.lang.reflect.Method"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="from" return="com.google.inject.persist.finder.DynamicFinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns some metadata if the method is annotated {@code @Finder} or null.

 @param method a method you want to test as a dynamic finder]]>
      </doc>
    </method>
    <method name="metadata" return="com.google.inject.persist.finder.Finder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility that helps you introspect dynamic finder methods.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.finder.DynamicFinder -->
  <!-- start interface com.google.inject.persist.finder.Finder -->
  <interface name="Finder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="namedQuery" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the configured named query's name. Specify a named query's name here. This name is
 typically specified in your JPA configuration.]]>
      </doc>
    </method>
    <method name="query" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the configured query string. Directly specify a JPAQL query here.]]>
      </doc>
    </method>
    <method name="returnAs" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the configured autoboxing collection class. Use this clause to specify a collection
 impl to autobox result lists into. The impl must have a default no-arg constructor and be a
 subclass of {@code java.util.Collection}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Marks a method stub as a dynamic finder. The method is intercepted and replaced with the
 specified JPAQL query. Provides result auto-boxing and automatic parameter binding.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.finder.Finder -->
  <!-- start interface com.google.inject.persist.finder.FirstResult -->
  <interface name="FirstResult"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotate any dynamic finder method's integer argument with this to pass in the index of the first
 result in the result set you are interested in. Useful for paging result sets. Complemented by
 {@link MaxResults}.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.finder.FirstResult -->
  <!-- start interface com.google.inject.persist.finder.MaxResults -->
  <interface name="MaxResults"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotate any dynamic finder method's integer argument with this to pass in the maximum size of
 returned result window. Usefule for paging result sets. Complement of {@link FirstResult}.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.finder.MaxResults -->
</package>
<package name="com.google.inject.persist.jpa">
  <!-- start class com.google.inject.persist.jpa.JpaPersistModule -->
  <class name="JpaPersistModule" extends="com.google.inject.persist.PersistModule"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JpaPersistModule" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configurePersistence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getTransactionInterceptor" return="org.aopalliance.intercept.MethodInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="properties" return="com.google.inject.persist.jpa.JpaPersistModule"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Map"/>
      <doc>
      <![CDATA[Configures the JPA persistence provider with a set of properties.

 @param properties A set of name value pairs that configure a JPA persistence provider as per
     the specification.
 @since 4.0 (since 3.0 with a parameter type of {@code java.util.Properties})]]>
      </doc>
    </method>
    <method name="addFinder" return="com.google.inject.persist.jpa.JpaPersistModule"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Adds an interface to this module to use as a dynamic finder.

 @param iface Any interface type whose methods are all dynamic finders.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[JPA provider for guice persist.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.jpa.JpaPersistModule -->
</package>
<package name="com.google.inject.persist">
  <!-- start class com.google.inject.persist.PersistFilter -->
  <class name="PersistFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PersistFilter" type="com.google.inject.persist.UnitOfWork, com.google.inject.persist.PersistService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterConfig" type="FilterConfig"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletRequest" type="ServletRequest"/>
      <param name="servletResponse" type="ServletResponse"/>
      <param name="filterChain" type="FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <doc>
    <![CDATA[Apply this filter to enable the HTTP Request unit of work and to have guice-persist manage the
 lifecycle of active units of work. The filter automatically starts and stops the relevant {@link
 PersistService} upon {@link javax.servlet.Filter#init(javax.servlet.FilterConfig)} and {@link
 javax.servlet.Filter#destroy()} respectively.

 <p>To be able to use the open session-in-view pattern (i.e. work per request), register this
 filter <b>once</b> in your Guice {@code ServletModule}. It is important that you register this
 filter before any other filter.

 <p>For multiple providers, you should register this filter once per provider, inside a private
 module for each persist module installed (this must be the same private module where the specific
 persist module is itself installed).

 <p>Example configuration:

 <pre>{@code
 public class MyModule extends ServletModule {
   public void configureServlets() {
     filter("/*").through(PersistFilter.class);

     serve("/index.html").with(MyHtmlServlet.class);
     // Etc.
   }
 }
 }</pre>

 <p>This filter is thread safe and allows you to create injectors concurrently and deploy multiple
 guice-persist modules within the same injector, or even multiple injectors with persist modules
 withing the same JVM or web app.

 <p>This filter requires the Guice Servlet extension.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.PersistFilter -->
  <!-- start class com.google.inject.persist.PersistModule -->
  <class name="PersistModule" extends="com.google.inject.AbstractModule"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PersistModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="configurePersistence"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getTransactionInterceptor" return="org.aopalliance.intercept.MethodInterceptor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Install this module to add guice-persist library support for JPA persistence providers.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.PersistModule -->
  <!-- start interface com.google.inject.persist.PersistService -->
  <interface name="PersistService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts the underlying persistence engine and makes guice-persist ready for use. For instance,
 with JPA, it creates an EntityManagerFactory and may open connection pools. This method must be
 called by your code prior to using any guice-persist or JPA artifacts. If already started,
 calling this method does nothing, if already stopped, it also does nothing.]]>
      </doc>
    </method>
    <method name="stop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops the underlying persistence engine. For instance, with JPA, it closes the {@code
 EntityManagerFactory}. If already stopped, calling this method does nothing. If not yet
 started, it also does nothing.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Persistence provider service. Use this to manage the overall startup and stop of the persistence
 module(s).

 <p>TODO(dhanji): Integrate with Service API when appropriate.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.PersistService -->
  <!-- start interface com.google.inject.persist.Transactional -->
  <interface name="Transactional"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="rollbackOn" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A list of exceptions to rollback on, if thrown by the transactional method. These exceptions
 are propagated correctly after a rollback.]]>
      </doc>
    </method>
    <method name="ignore" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A list of exceptions to <b>not<b> rollback on. A caveat to the rollbackOn clause. The
 disjunction of rollbackOn and ignore represents the list of exceptions that will trigger a
 rollback. The complement of rollbackOn and the universal set plus any exceptions in the ignore
 set represents the list of exceptions that will trigger a commit. Note that ignore exceptions
 take precedence over rollbackOn, but with subtype granularity.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Any method or class marked with this annotation will be considered for transactionality. Consult
 the documentation on https://github.com/google/guice/wiki/GuicePersist for detailed semantics.
 Marking a method {@code @Transactional} will start a new transaction before the method executes
 and commit it after the method returns.

 <p>If the method throws an exception, the transaction will be rolled back <em>unless</em> you
 have specifically requested not to in the {@link #ignore()} clause.

 <p>Similarly, the set of exceptions that will trigger a rollback can be defined in the {@link
 #rollbackOn()} clause. By default, only unchecked exceptions trigger a rollback.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.Transactional -->
  <!-- start interface com.google.inject.persist.UnitOfWork -->
  <interface name="UnitOfWork"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="begin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts a Unit Of Work. Underneath, causes a session to the data layer to be opened. If there is
 already one open, the invocation will do nothing. In this way, you can define arbitrary
 units-of-work that nest within one another safely.

 <p>Transaction semantics are not affected.]]>
      </doc>
    </method>
    <method name="end"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Declares an end to the current Unit of Work. Underneath, causes any open session to the data
 layer to close. If there is no Unit of work open, then the call returns silently. You can
 safely invoke end() repeatedly.

 <p>Transaction semantics are not affected.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface is used to gain manual control over the unit of work. This is mostly to do work in
 non-request, non-transactional threads. Or where more fine-grained control over the unit of work
 is required. Starting and ending a unit of work directly corresponds to opening and closing a
 {@code Session}, {@code EntityManager} or {@code ObjectContainer} respectively.

 <p>The Unit of Work referred to by UnitOfWork will always be local to the calling thread. Be
 careful to end() in a finally block. Neither JPA, nor Hibernate supports threadsafe sessions
 (reasoning behind thread-locality of Unit of Work semantics).

 <ul>
 <li>Using UnitOfWork with the PersistFilter inside a request is not recommended.
 <li>Using UnitOfWork with session-per-txn strategy is not terribly clever either.
 <li>Using UnitOfWork with session-per-request strategy but *outside* a request (i.e. in a
     background or bootstrap thread) is probably a good use case.
 </ul>

 @author Dhanji R. Prasanna (dhanji@gmail com)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.UnitOfWork -->
</package>

</api>
